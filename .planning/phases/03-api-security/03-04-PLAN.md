---
phase: 03-api-security
plan: 04
type: execute
wave: 2
depends_on: ["03-03"]
files_modified:
  - lib/admin/access-control.ts
  - app/api/admin/feature-flags/route.ts
  - app/api/admin/feature-flags/audit/route.ts
autonomous: true

must_haves:
  truths:
    - "Admin check queries admin_users table, not ADMIN_EMAILS env var"
    - "Non-admins receive 403 with audit log entry"
    - "Admin operations are logged with before/after state"
    - "ADMIN_EMAILS environment variable is no longer used"
  artifacts:
    - path: "lib/admin/access-control.ts"
      provides: "Admin access control utilities"
      exports: ["checkAdminAccess", "requireAdmin"]
      min_lines: 50
    - path: "app/api/admin/feature-flags/route.ts"
      provides: "Feature flags API with database admin check"
      contains: "requireAdmin"
  key_links:
    - from: "lib/admin/access-control.ts"
      to: "lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*supabase/server"
    - from: "lib/admin/access-control.ts"
      to: "lib/audit.ts"
      via: "logAdminAction import"
      pattern: "import.*logAdminAction.*audit"
    - from: "app/api/admin/feature-flags/route.ts"
      to: "lib/admin/access-control.ts"
      via: "requireAdmin import"
      pattern: "import.*requireAdmin.*access-control"
---

<objective>
Replace environment variable admin access with database-controlled access and audit logging.

Purpose: Completes SEC-04 - admin access via database table with full audit trail.
Output: Admin access control library, updated admin API routes.
</objective>

<execution_context>
@/Users/Vignesh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Vignesh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-api-security/03-03-SUMMARY.md

@lib/audit.ts
@app/api/admin/feature-flags/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin access control library</name>
  <files>lib/admin/access-control.ts</files>
  <action>
    Create new file with admin access utilities:

    ```typescript
    /**
     * Admin Access Control
     * SEC-04: Database-controlled admin access with audit logging
     */

    import { NextResponse } from "next/server";
    import { createClient } from "@/lib/supabase/server";
    import { logAdminAccessDenied, logAuditEvent } from "@/lib/audit";

    export interface AdminCheckResult {
      isAdmin: boolean;
      adminId?: string;
      userId?: string;
    }

    /**
     * Check if user has admin access via database
     * Does NOT check ADMIN_EMAILS - that pattern is deprecated
     */
    export async function checkAdminAccess(userId: string): Promise<AdminCheckResult> {
      const supabase = await createClient();

      const { data: adminRecord, error } = await supabase
        .from("admin_users")
        .select("id, user_id, granted_at")
        .eq("user_id", userId)
        .eq("is_active", true)
        .single();

      if (error || !adminRecord) {
        return { isAdmin: false, userId };
      }

      return {
        isAdmin: true,
        adminId: adminRecord.id,
        userId,
      };
    }

    export type RequireAdminResult =
      | { success: true; userId: string; adminId: string }
      | { success: false; response: NextResponse };

    /**
     * Require admin access for an API route
     * Returns user/admin IDs on success, NextResponse error on failure
     *
     * Usage:
     * ```
     * const result = await requireAdmin("/api/admin/feature-flags");
     * if (!result.success) return result.response;
     * const { userId, adminId } = result;
     * ```
     */
    export async function requireAdmin(requestPath: string): Promise<RequireAdminResult> {
      const supabase = await createClient();
      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (!user) {
        return {
          success: false,
          response: NextResponse.json({ error: "Unauthorized" }, { status: 401 }),
        };
      }

      const { isAdmin, adminId } = await checkAdminAccess(user.id);

      if (!isAdmin) {
        // Log unauthorized access attempt
        await logAdminAccessDenied(user.id, requestPath);

        return {
          success: false,
          response: NextResponse.json({ error: "Forbidden" }, { status: 403 }),
        };
      }

      // Log successful admin access
      await logAuditEvent({
        userId: user.id,
        actionType: "data_access",
        resourceType: "admin",
        performedBy: "admin",
        requestPath,
        responseStatus: 200,
        metadata: { admin_id: adminId },
      });

      return {
        success: true,
        userId: user.id,
        adminId: adminId!,
      };
    }

    /**
     * Grant admin access to a user
     * Must be called by an existing admin
     */
    export async function grantAdminAccess(
      grantedByAdminId: string,
      targetUserId: string,
      reason: string
    ): Promise<{ success: boolean; error?: string }> {
      const supabase = await createClient();

      // Check if target is already admin
      const { data: existing } = await supabase
        .from("admin_users")
        .select("id, is_active")
        .eq("user_id", targetUserId)
        .single();

      if (existing?.is_active) {
        return { success: false, error: "User is already an admin" };
      }

      // If revoked, reactivate. Otherwise, insert new.
      if (existing) {
        const { error } = await supabase
          .from("admin_users")
          .update({
            is_active: true,
            granted_by: grantedByAdminId,
            granted_at: new Date().toISOString(),
            revoked_at: null,
            revoked_by: null,
            reason,
            updated_at: new Date().toISOString(),
          })
          .eq("id", existing.id);

        if (error) {
          return { success: false, error: error.message };
        }
      } else {
        const { error } = await supabase.from("admin_users").insert({
          user_id: targetUserId,
          granted_by: grantedByAdminId,
          reason,
        });

        if (error) {
          return { success: false, error: error.message };
        }
      }

      return { success: true };
    }

    /**
     * Revoke admin access from a user
     * Must be called by an existing admin
     */
    export async function revokeAdminAccess(
      revokedByAdminId: string,
      targetUserId: string,
      reason: string
    ): Promise<{ success: boolean; error?: string }> {
      const supabase = await createClient();

      const { error } = await supabase
        .from("admin_users")
        .update({
          is_active: false,
          revoked_at: new Date().toISOString(),
          revoked_by: revokedByAdminId,
          reason,
          updated_at: new Date().toISOString(),
        })
        .eq("user_id", targetUserId)
        .eq("is_active", true);

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true };
    }
    ```

    Why: Centralizes admin access logic, ensures consistent audit logging, enables instant revocation.
  </action>
  <verify>npm run build (no type errors)</verify>
  <done>lib/admin/access-control.ts exports checkAdminAccess, requireAdmin, grantAdminAccess, revokeAdminAccess</done>
</task>

<task type="auto">
  <name>Task 2: Update feature flags API to use database admin check</name>
  <files>app/api/admin/feature-flags/route.ts</files>
  <action>
    Replace ADMIN_EMAILS check with requireAdmin:

    1. Remove ADMIN_EMAILS constant and isAdmin function (lines 13-36)
    2. Import requireAdmin: `import { requireAdmin } from "@/lib/admin/access-control"`
    3. Import logAdminAction: `import { logAdminAction } from "@/lib/audit"`

    4. Update GET handler:
       ```typescript
       export async function GET() {
         try {
           const result = await requireAdmin("/api/admin/feature-flags");
           if (!result.success) return result.response;

           const supabase = await createClient();
           // ... rest of existing logic
         }
       }
       ```

    5. Update PUT handler with before/after audit logging:
       ```typescript
       export async function PUT(request: NextRequest) {
         try {
           const result = await requireAdmin("/api/admin/feature-flags");
           if (!result.success) return result.response;

           const { adminId } = result;
           const supabase = await createClient();
           const body = await request.json();

           // Fetch before state
           const { data: beforeState } = await supabase
             .from("feature_flags")
             .select("*")
             .eq("id", body.id)
             .single();

           // ... existing update logic ...

           // Log admin action with before/after
           await logAdminAction(
             adminId,
             "admin_action",
             "feature_flag",
             body.id,
             {
               operation: "update_feature_flag",
               before: beforeState || undefined,
               after: updatedFlag || undefined,
             }
           );

           // ... rest of response
         }
       }
       ```

    6. Update POST and DELETE handlers similarly:
       - Use requireAdmin instead of isAdmin
       - Add logAdminAction calls for create/delete operations

    Why: Replaces env var check with database check, adds comprehensive audit trail.
  </action>
  <verify>npm run build (no type errors), grep "ADMIN_EMAILS" returns no matches in this file</verify>
  <done>Feature flags API uses requireAdmin, ADMIN_EMAILS removed, admin actions logged</done>
</task>

<task type="auto">
  <name>Task 3: Update feature flags audit route</name>
  <files>app/api/admin/feature-flags/audit/route.ts</files>
  <action>
    Update to use requireAdmin pattern:

    1. Check if this file uses ADMIN_EMAILS or isAdmin
    2. If yes, replace with requireAdmin import and usage
    3. If the file accesses admin_users table, ensure it uses the access control library

    Pattern:
    ```typescript
    import { requireAdmin } from "@/lib/admin/access-control";

    export async function GET() {
      const result = await requireAdmin("/api/admin/feature-flags/audit");
      if (!result.success) return result.response;

      // ... existing audit retrieval logic
    }
    ```

    Why: Consistent admin access control across all admin endpoints.
  </action>
  <verify>npm run build (no type errors)</verify>
  <done>Audit route uses requireAdmin pattern</done>
</task>

</tasks>

<verification>
1. npm run build - no type errors
2. grep -r "ADMIN_EMAILS" app/api/admin --include="*.ts" - should return NO matches
3. grep -r "requireAdmin" app/api/admin --include="*.ts" - should return matches in all admin routes
4. grep "logAdminAction" app/api/admin/feature-flags/route.ts - should return matches
</verification>

<success_criteria>
- ADMIN_EMAILS env var no longer used in any admin route
- All admin routes use requireAdmin from lib/admin/access-control.ts
- Admin mutations (PUT, POST, DELETE) log before/after state via logAdminAction
- Non-admin access attempts are logged with logAdminAccessDenied
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-security/03-04-SUMMARY.md`
</output>
