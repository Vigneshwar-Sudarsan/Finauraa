---
phase: 03-api-security
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260125_admin_users.sql
  - lib/database.types.ts
  - lib/audit.ts
autonomous: true

must_haves:
  truths:
    - "admin_users table exists in database"
    - "RLS policies restrict admin_users access to admins only"
    - "Existing ADMIN_EMAILS users are migrated to database"
    - "Audit logging supports admin action types"
  artifacts:
    - path: "supabase/migrations/20260125_admin_users.sql"
      provides: "Database migration for admin_users table"
      contains: "CREATE TABLE admin_users"
      min_lines: 30
    - path: "lib/audit.ts"
      provides: "Extended audit types for admin actions"
      contains: "admin_action"
  key_links:
    - from: "supabase/migrations/20260125_admin_users.sql"
      to: "auth.users"
      via: "foreign key reference"
      pattern: "REFERENCES auth.users"
---

<objective>
Create admin_users database table with RLS policies and extend audit logging for admin operations.

Purpose: Foundation for SEC-04 - database-controlled admin access with audit trail.
Output: Migration file, updated types, extended audit logging.
</objective>

<execution_context>
@/Users/Vignesh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Vignesh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-api-security/03-RESEARCH.md

@lib/audit.ts
@lib/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin_users migration</name>
  <files>supabase/migrations/20260125_admin_users.sql</files>
  <action>
    Create migration file with:

    ```sql
    -- Admin Users Table for SEC-04 compliance
    -- Replaces ADMIN_EMAILS environment variable with database-controlled access

    CREATE TABLE IF NOT EXISTS admin_users (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
      granted_by UUID REFERENCES auth.users(id),
      granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      revoked_at TIMESTAMPTZ,
      revoked_by UUID REFERENCES auth.users(id),
      reason TEXT,
      is_active BOOLEAN NOT NULL DEFAULT TRUE,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE(user_id)
    );

    -- Index for fast lookup of active admins
    CREATE INDEX idx_admin_users_active ON admin_users(user_id) WHERE is_active = true;

    -- Enable RLS
    ALTER TABLE admin_users ENABLE ROW LEVEL SECURITY;

    -- Self-referential policy: only admins can view admin list
    CREATE POLICY "Admins can view admin users"
      ON admin_users FOR SELECT
      USING (
        EXISTS (
          SELECT 1 FROM admin_users au
          WHERE au.user_id = auth.uid() AND au.is_active = true
        )
      );

    -- Only service role can insert/update/delete (via API)
    CREATE POLICY "Service role manages admin users"
      ON admin_users FOR ALL
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');

    -- Migration: Insert existing ADMIN_EMAILS if profiles exist
    -- This is a placeholder - actual emails will be inserted via seed script
    -- INSERT INTO admin_users (user_id, reason, granted_by)
    -- SELECT p.id, 'Initial admin from ADMIN_EMAILS migration', p.id
    -- FROM profiles p
    -- WHERE p.is_admin = true;

    COMMENT ON TABLE admin_users IS 'Stores admin user privileges with audit trail for SEC-04 compliance';
    COMMENT ON COLUMN admin_users.granted_by IS 'User who granted admin access (NULL for initial migration)';
    COMMENT ON COLUMN admin_users.revoked_at IS 'When admin access was revoked (NULL if active)';
    COMMENT ON COLUMN admin_users.reason IS 'Why this user was granted/revoked admin access';
    ```

    Why: Database table allows instant revocation without deployment, provides audit trail.
  </action>
  <verify>Check file exists with correct SQL syntax</verify>
  <done>Migration file creates admin_users table with RLS policies</done>
</task>

<task type="auto">
  <name>Task 2: Extend audit logging types</name>
  <files>lib/audit.ts</files>
  <action>
    Add admin-specific audit types and helper function:

    1. Extend AuditActionType union:
       ```typescript
       export type AuditActionType =
         | "data_access"
         // ... existing types
         | "admin_action"        // Admin performed an action
         | "admin_grant"         // Admin access was granted
         | "admin_revoke"        // Admin access was revoked
         | "admin_access_denied"; // Non-admin attempted admin action
       ```

    2. Extend AuditResourceType union:
       ```typescript
       export type AuditResourceType =
         | "profile"
         // ... existing types
         | "admin"              // Admin user record
         | "feature_flag"       // Feature flag (for admin operations)
         | "system_config";     // System configuration
       ```

    3. Add logAdminAction helper:
       ```typescript
       /**
        * Log admin operations with before/after state
        */
       export async function logAdminAction(
         adminUserId: string,
         action: "admin_action" | "admin_grant" | "admin_revoke",
         resourceType: AuditResourceType,
         resourceId: string,
         details: {
           operation: string;
           before?: Record<string, unknown>;
           after?: Record<string, unknown>;
           reason?: string;
         }
       ): Promise<string | null> {
         return logAuditEvent({
           userId: adminUserId,
           actionType: action,
           resourceType,
           resourceId,
           performedBy: "admin",
           metadata: {
             operation: details.operation,
             before: details.before,
             after: details.after,
             reason: details.reason,
             fields_changed: details.before && details.after
               ? Object.keys(details.after).filter(
                   k => JSON.stringify(details.before?.[k]) !== JSON.stringify(details.after?.[k])
                 )
               : undefined,
           },
         });
       }

       /**
        * Log unauthorized admin access attempt
        */
       export async function logAdminAccessDenied(
         userId: string,
         attemptedPath: string
       ): Promise<string | null> {
         return logAuditEvent({
           userId,
           actionType: "admin_access_denied",
           resourceType: "admin",
           performedBy: "user",
           requestPath: attemptedPath,
           responseStatus: 403,
           metadata: { reason: "not_admin" },
         });
       }
       ```

    Why: Detailed admin audit logging required for SEC-04 compliance and security monitoring.
  </action>
  <verify>npm run build (no type errors)</verify>
  <done>Audit types extended with admin_action, admin_grant, admin_revoke, logAdminAction helper added</done>
</task>

<task type="auto">
  <name>Task 3: Regenerate database types</name>
  <files>lib/database.types.ts</files>
  <action>
    After the migration is applied, regenerate database types:

    1. Run migration locally:
       ```bash
       npx supabase db push
       ```
       OR if using Supabase CLI migrations:
       ```bash
       npx supabase migration up
       ```

    2. Regenerate types:
       ```bash
       npx supabase gen types typescript --local > lib/database.types.ts
       ```

    3. Verify admin_users type exists in generated file:
       - Should have Row, Insert, Update types
       - Should include user_id, granted_by, is_active, etc.

    If type generation fails or is not available locally, manually add the type:
    ```typescript
    admin_users: {
      Row: {
        id: string
        user_id: string
        granted_by: string | null
        granted_at: string
        revoked_at: string | null
        revoked_by: string | null
        reason: string | null
        is_active: boolean
        created_at: string
        updated_at: string
      }
      Insert: {
        id?: string
        user_id: string
        granted_by?: string | null
        granted_at?: string
        revoked_at?: string | null
        revoked_by?: string | null
        reason?: string | null
        is_active?: boolean
        created_at?: string
        updated_at?: string
      }
      Update: {
        id?: string
        user_id?: string
        granted_by?: string | null
        granted_at?: string
        revoked_at?: string | null
        revoked_by?: string | null
        reason?: string | null
        is_active?: boolean
        created_at?: string
        updated_at?: string
      }
      Relationships: []
    }
    ```

    Why: TypeScript types ensure type-safe access to admin_users table.
  </action>
  <verify>npm run build (no type errors), admin_users type exists in database.types.ts</verify>
  <done>database.types.ts includes admin_users table types</done>
</task>

</tasks>

<verification>
1. Migration file exists: ls supabase/migrations/*admin_users*
2. npm run build - no type errors
3. grep "admin_action" lib/audit.ts - returns matches
4. grep "admin_users" lib/database.types.ts - returns matches
</verification>

<success_criteria>
- Migration file creates admin_users with correct schema
- RLS policies allow only admins to view admin list
- Audit types include admin_action, admin_grant, admin_revoke
- logAdminAction helper function exists
- database.types.ts includes admin_users type
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-security/03-03-SUMMARY.md`
</output>
