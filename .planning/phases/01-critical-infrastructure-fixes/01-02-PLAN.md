---
phase: 01-critical-infrastructure-fixes
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/consent-middleware.ts
  - lib/__tests__/consent-middleware.test.ts
  - sentry.client.config.ts
  - sentry.server.config.ts
autonomous: true

must_haves:
  truths:
    - "All consent error cases return identical response structure"
    - "Error responses include typed code, user message, and requiresConsent flag"
    - "NO_BANKS case returns 200 with empty data flag (not 403)"
    - "Sentry alerts configured for infrastructure failures"
    - "Tests cover all edge cases (no consent, expired, revoked, no banks, check failed)"
  artifacts:
    - path: "lib/consent-middleware.ts"
      provides: "Consent middleware with consistent error responses"
      contains: "ConsentErrorCode"
    - path: "lib/__tests__/consent-middleware.test.ts"
      provides: "Tests for all consent edge cases"
      contains: "describe.*consent"
    - path: "sentry.server.config.ts"
      provides: "Sentry server config with infrastructure alerts"
      contains: "beforeSend"
  key_links:
    - from: "lib/consent-middleware.ts"
      to: "API routes"
      via: "requireBankConsent function"
      pattern: "requireBankConsent"
    - from: "sentry.server.config.ts"
      to: "rate limiter errors"
      via: "tag filtering"
      pattern: "component.*rate_limiter"
---

<objective>
Ensure consent middleware returns consistent error responses for all edge cases and configure Sentry alerting for infrastructure failures.

Purpose: The consent middleware currently has inconsistent behavior - NO_BANKS returns a successful response with a flag, while other errors return 403. Frontend code needs to handle multiple response shapes. Standardizing the error structure simplifies frontend handling and ensures predictable behavior. Additionally, Sentry needs configuration to surface infrastructure failures.

Output: Unified consent error handling with complete test coverage, and production-ready Sentry alerting.
</objective>

<execution_context>
@/Users/Vignesh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Vignesh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-infrastructure-fixes/01-RESEARCH.md
@.planning/phases/01-critical-infrastructure-fixes/01-01-SUMMARY.md

# Existing implementation to refactor
@lib/consent-middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor consent middleware for consistent error responses</name>
  <files>
    lib/consent-middleware.ts
  </files>
  <action>
    The current consent middleware has a design decision to clarify:
    - NO_BANKS: Currently returns `{ hasConsent: true, noBanksConnected: true }` - user allowed, API returns empty data
    - Other errors: Return `{ hasConsent: false, error, errorCode }` - user blocked with 403

    This is INTENTIONAL per line 54-59 comments: "If no bank connections, no consent is needed - user just hasn't connected yet. API routes should return empty data, not 403"

    The inconsistency is NOT in consent middleware itself, but in documentation. The current behavior is correct:
    - New user with no banks: Show empty dashboard, prompt to connect
    - User with banks but no/expired/revoked consent: Block with 403, require re-auth

    Refactor for CLARITY while preserving this intentional behavior:

    1. Create explicit response type factory:
    ```typescript
    // Consent check result types - clearly separated
    type ConsentAllowed =
      | { allowed: true; consentId: string; noBanksConnected?: false }
      | { allowed: true; noBanksConnected: true };

    type ConsentDenied = {
      allowed: false;
      error: {
        message: string;           // User-facing message
        code: ConsentErrorCode;    // Machine-readable code
        requiresConsent: boolean;  // Frontend should redirect to consent flow
      };
    };

    export type ConsentResult = ConsentAllowed | ConsentDenied;
    ```

    2. Create factory functions for error responses:
    ```typescript
    function createConsentError(
      code: ConsentErrorCode,
      message: string
    ): ConsentDenied {
      return {
        allowed: false,
        error: {
          message,
          code,
          requiresConsent: code !== 'CHECK_FAILED', // Only CHECK_FAILED doesn't need re-consent
        },
      };
    }
    ```

    3. Update checkBankAccessConsent to use new types:
       - Keep noBanksConnected behavior (allowed: true, API returns empty)
       - Use createConsentError for all error cases
       - Ensure all error paths go through factory

    4. Update requireBankConsent to use new types:
       - Match return type to new ConsentResult
       - When allowed: false, create NextResponse with consistent shape:
         ```typescript
         {
           error: result.error.message,
           code: result.error.code,
           requiresConsent: result.error.requiresConsent,
         }
         ```

    5. Update withConsentCheck to use new types consistently

    6. Add Sentry logging for CHECK_FAILED cases (database errors):
    ```typescript
    import * as Sentry from '@sentry/nextjs';

    // In catch block
    Sentry.captureException(error, {
      tags: {
        component: 'consent_middleware',
        failure_mode: 'database_error',
      },
    });
    ```

    IMPORTANT: The NO_BANKS case should NOT return 403. This is intentional design - new users shouldn't see errors before connecting their first bank.
  </action>
  <verify>
    Check lib/consent-middleware.ts:
    - ConsentResult type exists with clear allowed/denied variants
    - All error paths use createConsentError factory
    - NO_BANKS returns { allowed: true, noBanksConnected: true } (NOT 403)
    - CHECK_FAILED logs to Sentry
    Run `npm run build` to verify TypeScript compiles
  </verify>
  <done>
    All consent errors use consistent factory function
    Types clearly document allowed vs denied variants
    NO_BANKS behavior preserved (empty data, not 403)
    Sentry captures database errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Sentry infrastructure alerts</name>
  <files>
    sentry.server.config.ts
    sentry.client.config.ts
  </files>
  <action>
    First, check if Sentry config files exist:
    - sentry.server.config.ts
    - sentry.client.config.ts

    If they exist, update them. If not, Sentry initialization may be in next.config.js or instrumentation.ts.

    Configure Sentry for infrastructure alerting:

    1. In sentry.server.config.ts, add beforeSend hook to tag infrastructure errors:
    ```typescript
    import * as Sentry from '@sentry/nextjs';

    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,

      // Tag infrastructure failures for alerting
      beforeSend(event, hint) {
        // Check if this is an infrastructure error we've already tagged
        const component = event.tags?.component;
        if (component === 'rate_limiter' || component === 'consent_middleware') {
          // Ensure high priority for infrastructure issues
          event.level = 'error';

          // Add fingerprint for grouping
          event.fingerprint = [
            component,
            event.tags?.failure_mode || 'unknown',
          ];
        }
        return event;
      },

      // Sample rate for errors (100% for infrastructure issues)
      sampleRate: 1.0,

      // Enable source maps
      integrations: [
        // Keep existing integrations
      ],
    });
    ```

    2. If sentry.client.config.ts exists, ensure it doesn't filter out infrastructure errors:
    ```typescript
    beforeSend(event) {
      // Don't filter infrastructure errors - they should reach server Sentry
      return event;
    }
    ```

    3. Create alert rules documentation (not actual Sentry config - that's in dashboard):
       Add comment in sentry.server.config.ts:
    ```typescript
    /**
     * Infrastructure Alert Rules (configure in Sentry Dashboard):
     *
     * 1. Rate Limiter Fallback Alert:
     *    - Filter: tags.component = 'rate_limiter' AND tags.failure_mode = 'database_unavailable'
     *    - Threshold: 1 event in 1 minute
     *    - Action: Slack/email notification
     *
     * 2. Consent Middleware Database Error:
     *    - Filter: tags.component = 'consent_middleware' AND tags.failure_mode = 'database_error'
     *    - Threshold: 5 events in 5 minutes
     *    - Action: Slack/email notification
     */
    ```
  </action>
  <verify>
    Check sentry.server.config.ts:
    - beforeSend hook exists
    - Infrastructure errors tagged appropriately
    - Alert rule documentation comment exists
    Run `npm run build` to verify no errors
  </verify>
  <done>
    Sentry config updated with infrastructure error handling
    beforeSend hook properly tags and prioritizes errors
    Alert rule documentation added for team setup
  </done>
</task>

<task type="auto">
  <name>Task 3: Write tests for consent middleware edge cases</name>
  <files>
    lib/__tests__/consent-middleware.test.ts
  </files>
  <action>
    Create lib/__tests__/consent-middleware.test.ts with tests for ALL edge cases:

    1. "returns allowed with noBanksConnected when user has no bank connections":
       - Mock bank_connections query to return count: 0
       - Call checkBankAccessConsent
       - Verify: { allowed: true, noBanksConnected: true }
       - Verify NOT: { allowed: false } or 403 response

    2. "returns allowed with consentId when user has valid consent":
       - Mock bank_connections to return count > 0
       - Mock user_consents to return active, non-expired consent
       - Verify: { allowed: true, consentId: 'xxx' }

    3. "returns CONSENT_EXPIRED when consent exists but expired":
       - Mock bank_connections count > 0
       - Mock user_consents first query to fail (PGRST116 - no active consent)
       - Mock second query to return consent with expired status or past date
       - Verify: { allowed: false, error.code: 'CONSENT_EXPIRED' }

    4. "returns CONSENT_REVOKED when consent has been revoked":
       - Mock bank_connections count > 0
       - Mock user_consents queries to show revoked consent
       - Verify: { allowed: false, error.code: 'CONSENT_REVOKED' }

    5. "returns NO_CONSENT when user has banks but never consented":
       - Mock bank_connections count > 0
       - Mock user_consents to return no records (PGRST116) and no expired/revoked
       - Verify: { allowed: false, error.code: 'NO_CONSENT' }

    6. "returns CHECK_FAILED and logs to Sentry on database error":
       - Mock Supabase to throw exception
       - Mock Sentry.captureException
       - Verify: { allowed: false, error.code: 'CHECK_FAILED' }
       - Verify Sentry.captureException was called

    7. "requireBankConsent returns 403 response for denied cases":
       - Mock consent check to return denied
       - Call requireBankConsent
       - Verify response.status === 403
       - Verify response body has { error, code, requiresConsent }

    8. "requireBankConsent returns allowed for noBanksConnected":
       - Mock no banks
       - Call requireBankConsent
       - Verify: { allowed: true, noBanksConnected: true }
       - Verify NOT a NextResponse (not 403)

    Mock pattern for Supabase:
    ```typescript
    // Use vi.mock at top level
    vi.mock('@supabase/supabase-js', () => ({
      createClient: vi.fn()
    }));

    // In beforeEach, create mock with specific behavior
    const mockFrom = vi.fn();
    mockSupabase = { from: mockFrom };

    // Configure chain for specific test
    mockFrom.mockReturnValueOnce({
      select: vi.fn(() => ({
        eq: vi.fn(() => ({
          in: vi.fn(() => Promise.resolve({ count: 0 }))
        }))
      }))
    });
    ```
  </action>
  <verify>
    Run `npm run test:run lib/__tests__/consent-middleware.test.ts`
    All 8 tests pass
    Tests cover all ConsentErrorCode values
  </verify>
  <done>
    All 8 test cases pass
    Every ConsentErrorCode has at least one test
    NO_BANKS behavior verified as allowed (not denied)
    Sentry logging verified for CHECK_FAILED
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run full test suite: `npm run test:run`
2. Verify build succeeds: `npm run build`
3. Check consent error response consistency:
   - All denied cases have { error.message, error.code, error.requiresConsent }
   - NO_BANKS case returns { allowed: true, noBanksConnected: true }
4. Verify Sentry config has beforeSend hook
</verification>

<success_criteria>
- All consent errors use consistent factory function and response structure
- NO_BANKS intentionally returns allowed (empty data behavior preserved)
- Sentry configured to prioritize infrastructure errors
- 8 tests covering all edge cases pass
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-infrastructure-fixes/01-02-SUMMARY.md`
</output>
