---
phase: 01-critical-infrastructure-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vitest.config.mts
  - vitest.setup.ts
  - lib/ratelimit.ts
  - lib/__tests__/ratelimit.test.ts
autonomous: true

must_haves:
  truths:
    - "Rate limiter blocks requests when Supabase is unavailable (fail-closed with fallback)"
    - "Rate limiter uses stricter in-memory limits during database failure (10/min vs 60/min)"
    - "Infrastructure failures are logged to Sentry with appropriate tags"
    - "Tests verify fail-closed behavior and fallback activation"
  artifacts:
    - path: "vitest.config.mts"
      provides: "Vitest configuration for Next.js"
      contains: "defineConfig"
    - path: "vitest.setup.ts"
      provides: "Test setup with globals"
      min_lines: 5
    - path: "lib/ratelimit.ts"
      provides: "Rate limiter with insurance fallback pattern"
      contains: "RateLimiterMemory"
    - path: "lib/__tests__/ratelimit.test.ts"
      provides: "Rate limiter tests covering fail-closed behavior"
      contains: "describe.*ratelimit"
  key_links:
    - from: "lib/ratelimit.ts"
      to: "rate-limiter-flexible"
      via: "RateLimiterMemory import"
      pattern: "from 'rate-limiter-flexible'"
    - from: "lib/ratelimit.ts"
      to: "@sentry/nextjs"
      via: "captureException on fallback"
      pattern: "Sentry\\.captureException"
---

<objective>
Implement fail-safe rate limiting with in-memory fallback when Supabase is unavailable.

Purpose: The current rate limiter fails open (allows unlimited requests) when the database is unavailable. This is a critical security flaw - attackers could exploit database outages to bypass rate limiting. The fix implements an insurance pattern: try Supabase first, fall back to stricter in-memory limits if database fails.

Output: Working rate limiter that never fails open, with tests proving the behavior.
</objective>

<execution_context>
@/Users/Vignesh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Vignesh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-infrastructure-fixes/01-RESEARCH.md

# Existing implementation to refactor
@lib/ratelimit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Vitest testing infrastructure</name>
  <files>
    package.json
    vitest.config.mts
    vitest.setup.ts
  </files>
  <action>
    Install Vitest and testing dependencies:
    ```bash
    npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
    ```

    Add test script to package.json:
    ```json
    "scripts": {
      "test": "vitest",
      "test:run": "vitest run",
      "test:coverage": "vitest run --coverage"
    }
    ```

    Create vitest.config.mts following Next.js 16 official recommendations:
    - Use vite-tsconfig-paths for @ path alias resolution
    - Set environment to jsdom for DOM testing
    - Enable globals (describe, it, expect without imports)
    - Include pattern: **/*.{test,spec}.{ts,tsx}
    - Exclude node_modules, .next, dist

    Create vitest.setup.ts:
    - Import @testing-library/jest-dom/vitest (if using) or leave minimal
    - Any global test utilities needed
  </action>
  <verify>
    Run `npm run test:run` - should complete (even with no tests yet)
    Check that `vitest.config.mts` exists and imports tsconfigPaths
  </verify>
  <done>
    Vitest runs successfully with no errors
    package.json has test scripts
    vitest.config.mts exists with correct configuration
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rate limiter with in-memory fallback</name>
  <files>
    lib/ratelimit.ts
    package.json
  </files>
  <action>
    Install rate-limiter-flexible:
    ```bash
    npm install rate-limiter-flexible
    ```

    Refactor lib/ratelimit.ts to implement insurance pattern:

    1. Create in-memory fallback limiter with STRICTER limits:
       - RateLimiterMemory from rate-limiter-flexible
       - For 'api' type: 10/min (vs 60/min normal) - 6x stricter
       - For 'auth' type: 2/15min (vs 5/15min) - 2.5x stricter
       - For other types: proportionally stricter

    2. Modify checkRateLimit function:
       - Keep existing Supabase logic as primary
       - Wrap database calls in try-catch
       - On ANY database error (fetch error, update error, insert error):
         a. Log error with console.error (existing behavior)
         b. Capture to Sentry with infrastructure tags:
            ```typescript
            Sentry.captureException(error, {
              tags: {
                component: 'rate_limiter',
                failure_mode: 'database_unavailable',
                rate_limit_type: type,
              },
              contexts: {
                infrastructure: {
                  fallback_active: true,
                  service: 'supabase',
                  user_id: userId,
                }
              }
            });
            ```
         c. Fall back to in-memory limiter
         d. Return 429 if in-memory limit exceeded

    3. When Supabase client not configured (missing env vars):
       - Use in-memory limiter (not fail-open!)
       - Log warning about missing configuration

    4. Keep existing rateLimitConfigs and getRateLimitHeaders unchanged

    IMPORTANT: Do NOT fail open. Every code path must either:
    - Allow request (rate limit not exceeded)
    - Block request with 429 (rate limit exceeded)
    Never silently allow unlimited requests.
  </action>
  <verify>
    Check lib/ratelimit.ts:
    - Imports RateLimiterMemory from rate-limiter-flexible
    - Imports Sentry from @sentry/nextjs
    - No `return null` after error (fail-open)
    - In-memory fallback has stricter limits than database
    Run `npm run build` to verify no TypeScript errors
  </verify>
  <done>
    Rate limiter uses in-memory fallback on database failure
    Sentry captures infrastructure errors with proper tags
    No code path allows fail-open behavior
  </done>
</task>

<task type="auto">
  <name>Task 3: Write tests for rate limiter behavior</name>
  <files>
    lib/__tests__/ratelimit.test.ts
  </files>
  <action>
    Create lib/__tests__/ratelimit.test.ts with tests for:

    1. "blocks requests when Supabase unavailable":
       - Mock Supabase to throw error
       - Call checkRateLimit 11 times (exceeds fallback limit of 10)
       - Verify 11th call returns 429 response

    2. "uses stricter limits during fallback":
       - Mock Supabase to throw error
       - Call checkRateLimit with 'api' type 10 times
       - 10th should succeed (at limit)
       - 11th should return 429
       - Verify limit is 10, not 60

    3. "returns 429 when rate limited in memory":
       - Mock Supabase error
       - Exhaust fallback limit
       - Verify response has status 429 and retryAfter field

    4. "logs to Sentry when falling back to memory":
       - Mock Supabase error
       - Mock Sentry.captureException
       - Call checkRateLimit
       - Verify Sentry called with correct tags

    5. "allows request when under database limit":
       - Mock successful Supabase response (count = 5, max = 60)
       - Verify returns null (allowed)

    6. "blocks request when over database limit":
       - Mock Supabase response with count >= maxRequests
       - Verify returns 429 response

    Use vi.mock for mocking:
    - Mock @supabase/supabase-js createClient
    - Mock @sentry/nextjs for captureException spy
    - Use beforeEach to reset mocks between tests

    Pattern for mocking Supabase:
    ```typescript
    vi.mock('@supabase/supabase-js', () => ({
      createClient: vi.fn(() => ({
        from: vi.fn(() => ({
          select: vi.fn(() => ({
            eq: vi.fn(() => ({
              eq: vi.fn(() => ({
                gte: vi.fn(() => ({
                  order: vi.fn(() => ({
                    limit: vi.fn(() => Promise.resolve({ data: [], error: null }))
                  }))
                }))
              }))
            }))
          }))
        }))
      }))
    }));
    ```
  </action>
  <verify>
    Run `npm run test:run lib/__tests__/ratelimit.test.ts`
    All tests pass
    Tests cover both success and failure scenarios
  </verify>
  <done>
    All 6 test cases pass
    Tests verify fail-closed behavior
    Tests verify Sentry logging on fallback
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run full test suite: `npm run test:run`
2. Verify build succeeds: `npm run build`
3. Manual check: Search lib/ratelimit.ts for `return null` after catch blocks - should not exist
4. Verify Sentry import exists in rate limiter
</verification>

<success_criteria>
- Vitest testing infrastructure configured and working
- Rate limiter uses in-memory fallback when Supabase fails
- In-memory fallback has stricter limits (10/min vs 60/min for api type)
- Sentry captures infrastructure failures with appropriate tags
- All tests pass verifying fail-closed behavior
- No code path allows unlimited requests
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-infrastructure-fixes/01-01-SUMMARY.md`
</output>
